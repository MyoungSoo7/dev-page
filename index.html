
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Highlight.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/dark.min.css">
    <!-- Highlight.js JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>

    <title>리팩토링에서 중요한 것</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: auto;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        h1, h2, h3, h4 {
            border-left: 5px solid #0078D7;
            padding-left: 10px;
            color: #0078D7;
        }
        h1 {
            font-size: 2em;
            margin-top: 20px;
        }
        h2 {
            font-size: 1.8em;
            margin-top: 15px;
        }
        h3 {
            font-size: 1.5em;
            margin-top: 15px;
        }
        h4 {
            font-size: 1.2em;
        }
        p {
            margin: 10px 0;
        }
        ul, ol {
            margin: 10px 20px;
            padding: 0;
        }
        li {
            margin-bottom: 10px;
        }
        pre {
            background-color: #ececec;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: monospace, Arial;
        } 
       
        .highlight {
            font-weight: bold;
            color: #000;
        }
    </style>
</head>
<body>
    <a href="tdd-page.html">두 번째 TDD 페이지로 이동</a>      
   <a href="third-page.html">세 번째 페이지로 이동</a>    
    <a href="fourth-page.html">네 번째 페이지로 이동</a>
    <a href="fifth-page.html">다섯 번째 페이지로 이동</a>    
    <a href="fifth-page.html">여섯 번째 페이지로 이동</a>    
    <div class="container">
        <h1>[1] 리팩토링에서 중요한 것</h1>
        <p>리팩토링(refactoring)은 코드의 동작(기능)을 변경하지 않고, 구조를 개선하여 가독성, 유지 보수성, 효율성을 높이는 것을 목표로 합니다.</p>
        
        <h2>1. 리팩토링의 목적 이해</h2>
        <ul>
            <li><strong>기존 코드의 기능 보존:</strong> 기존 코드의 동작은 유지되어야 합니다.</li>
            <li><strong>코드 품질 개선:</strong> 가독성을 높이고 중복 코드를 제거하며 구조를 간결하게 만듭니다.</li>
            <li><strong>확장성 확보:</strong> 새로운 요구 사항이 생겨도 유연하게 대응할 수 있도록 코드 구조를 개선합니다.</li>
            <li><strong>버그 가능성 감소:</strong> 복잡한 코드를 단순화하여 개발과 디버깅에 소요되는 시간을 줄입니다.</li>
        </ul>

        <h2>2. 테스트의 중요성</h2>
        <p>리팩토링의 핵심은 테스트입니다.</p>
        <ul>
            <li><strong>자동화 테스트 작성:</strong> 리팩토링 전후의 결과가 동일한지 보장합니다.</li>
            <li><strong>테스트 주도 리팩토링:</strong> 안정성을 위해 테스트가 통과되었는지를 기준으로 작업을 진행합니다.</li>
        </ul>

        <h2>3. 코드의 냄새(Code Smell) 식별</h2>
        <p>리팩토링은 "코드 냄새"로부터 시작됩니다. 이는 문제가 있어 보이는 코드의 신호입니다.</p>
        <ul>
            <li><strong>중복 코드:</strong> 동일하거나 유사한 코드가 반복될 때.</li>
            <li><strong>긴 함수:</strong> 너무 많은 일을 하는 거대한 함수.</li>
            <li><strong>긴 클래스:</strong> 책임이 많아 관리하기 어려운 클래스.</li>
            <li><strong>의존성 문제:</strong> 지나치게 강한 결합(Coupling).</li>
            <li><strong>의미 없는 이름:</strong> 변수, 함수, 클래스의 이름이 의도를 전달하지 못할 때.</li>
        </ul>

        <h2>4. 리팩토링 과정</h2>
        <ul>
            <li><strong>코드 이해:</strong> 코드를 완전히 이해하고 기능을 파악합니다.</li>
            <li><strong>테스트 코드 작성:</strong> 기능이 동일한지 확인합니다.</li>
            <li><strong>작은 단위로 리팩토링:</strong> 한 번에 너무 많은 코드를 변경하지 않습니다.</li>
            <li><strong>주기적인 커밋:</strong> 롤백 가능성을 확보하기 위해 자주 저장합니다.</li>
        </ul>

        <h2>5. 주요 리팩토링 기법</h2>
        <ul>
            <li><strong>메서드 추출(Extract Method):</strong> 긴 함수의 일부를 별도로 분리합니다.</li>
            <li><strong>이름 변경(Rename Variable/Method):</strong> 의미를 명확히 합니다.</li>
            <li><strong>중복 코드 제거(Remove Duplicate Code):</strong> 중복된 코드를 통합합니다.</li>
            <li><strong>매직 넘버 치환:</strong> 반복된 숫자를 상수로 변환합니다.</li>
            <li><strong>조건문 단순화(Decompose Conditional):</strong> 복잡한 조건문을 간단화합니다.</li>
        </ul>

        <h2>6. 지속적으로 리팩토링</h2>
        <p>리팩토링은 한 번에 끝나는 작업이 아니라, 꾸준히 진행되어야 합니다.</p>
        
        <h2>7. 팀 커뮤니케이션</h2>
        <p>리팩토링은 팀원 모두의 합의와 협력이 필요합니다. 코드 리뷰를 통해 변경 사항을 논의하세요.</p>
        
        <h2>[2] 리팩토링 방법</h2>
        <h3>1. 클린 코드(Clean Code)</h3>
        <h4>클린 코드 특징</h4>
        <ul>
            <li><strong>명확하고 간결함:</strong> 코드는 불필요하게 복잡하지 않아야 하며, 명확한 로직 흐름을 가져야 합니다.</li>
            <li><strong>가독성:</strong> 코드를 읽는 사람이 빠르게 이해할 수 있도록 구조와 네이밍이 명확해야 합니다.</li>
            <li><strong>일관성:</strong> 코드 스타일과 작성 규칙이 프로젝트 전반에서 일관되게 유지되어야 합니다.</li>
            <li><strong>최소한의 중복(DRY - Don't Repeat Yourself):</strong> 반복되는 코드가 최소화되어야 하며, 재사용성을 높이는 구조가 중요합니다.</li>
            <li><strong>테스트 용이성:</strong> 작성된 코드는 쉽게 테스트될 수 있어야 합니다.</li>
            <li><strong>확장 가능성:</strong> 새로운 요구사항이 생겨도 코드 수정이 불필요하거나 최소화될 수 있는 설계 구조를 가져야 합니다.</li>
            <li><strong>오류 처리와 예외 처리 강화:</strong></li>
            <li><strong>클래스와 메서드의 단일 책임(Single Responsibility Principle) 준수:</strong></li>
            <li><strong>테스트 코드를 작성:</strong></li>
            <li><strong>적절한 캡슐화 활용:</strong></li>
        </ul>        
        <h4>클린 코드 작성의 장점</h4>
        <ul>
            <li>유지보수 시간 및 비용 감소</li>
            <li>팀원 간 협업과 코드 리뷰 효율성 향상</li>
            <li>버그 발생 가능성 감소</li>
            <li>코드 확장 및 리팩토링 용이</li>
        </ul> 
       

        <h3>2. 클린 아키텍처(Clean Architecture)</h3>        
            <p>클린 아키텍처는 소프트웨어 시스템의 구조를 설계하는 원칙과 접근 방식으로, 2012년 로버트 C. 마틴(Robert C. Martin, "Uncle Bob")이 제안한 개념입니다.</p>
            <p>이 아키텍처의 주된 목표는 유지보수성과 확장 가능성, 그리고 테스트 용이성을 높이는 것입니다. 클린 아키텍처는 <span class="highlight">응집도를 높이고 결합도를 낮춘다</span>는 소프트웨어 설계의 고전적인 원칙에 기반을 두고 있으며, 특히 프로젝트가 커지고 복잡도가 증가할 때 시스템이 복잡해지는 것을 방지합니다.</p>
        
            <h4>클린 아키텍처의 핵심 개념</h4>
            <h5>의존성 규칙(The Dependency Rule)</h5>
            <p>내부 계층은 외부 계층에 절대 의존하지 않습니다. 의존성은 항상 <span class="highlight">바깥에서 안쪽으로</span>만 흐릅니다. 즉, 고수준 모듈(비즈니스 로직)은 낮은 수준의 모듈(데이터베이스, 프레임워크 등)에 의존하지 않아야 합니다.</p>
        
            <h4>엔티티(Entity)</h4>
            <p>애플리케이션의 핵심 비즈니스 데이터와 규칙(도메인 로직)을 정의합니다. 외부 환경(예: 데이터베이스, UI 등)에 영향을 받지 않아야 합니다.</p>
        
            <h4>유즈케이스(Use Case)</h4>
            <p>애플리케이션의 비즈니스 규칙을 캡슐화합니다. 유즈케이스는 특정 사용자 작업이나 요구사항을 처리하는 데 중점을 둡니다.</p>
        
            <h4>계층(Layers)</h4>
            <p>클린 아키텍처에서는 애플리케이션을 여러 계층으로 나누고, 각 계층이 특정 역할을 수행하도록 설계합니다:</p>
            <ul>
                <li><span class="highlight">엔티티(Entity 또는 Domain)</span>: 비즈니스 핵심 규칙이 여기에 포함됩니다.</li>
                <li><span class="highlight">유즈케이스(Application Layer)</span>: 비즈니스 로직이나 워크플로를 처리하며, 어떤 UI나 데이터베이스에도 의존하지 않습니다.</li>
                <li><span class="highlight">인터페이스 및 어댑터(Interface Adapters)</span>: 유저 인터페이스, REST API 또는 다른 외부 시스템과 상호작용.</li>
                <li><span class="highlight">프레임워크 및 드라이버(Frameworks and Drivers)</span>: 데이터베이스, 웹 서버, 외부 라이브러리 등 특정 기술과 관련된 구현부.</li>
            </ul>
        
            <h4>독립성(Independence)</h4>
            <p>코드는 특정 프레임워크에 종속되지 않아야 합니다. UI, 데이터베이스, 외부 API 등과 독립적으로 동작해야 합니다.</p>
        
            <h4>클린 아키텍처의 구조</h4>
            <p>클린 아키텍처는 <span class="highlight">동심원 형태(Circular Layers)</span>를 따릅니다. 각 계층은 다음과 같이 중심으로부터 나열됩니다:</p>
            <ul>
                <li><span class="highlight">Entities (엔티티)</span>: 애플리케이션의 핵심 비즈니스 로직(도메인 모델)을 포함. 가장 안쪽 계층으로, 외부 세계와는 완전히 독립적이어야 합니다. <i>예: BankAccount 클래스와 관련된 잔액 계산 로직 등.</i></li>
                <li><span class="highlight">Use Cases (유즈케이스)</span>: 애플리케이션의 비즈니스 규칙과 워크플로. 엔티티와 상호작용하여 사용자 요구사항을 구현. <i>예: "계좌 송금" 기능, "사용자 로그인" 로직.</i></li>
                <li><span class="highlight">Interface Adapters (인터페이스 어댑터)</span>: 외부로부터 입력 데이터를 받아 애플리케이션 내부로 전달하고, 내부 데이터 구조를 외부 시스템에서 이해할 수 있는 형식으로 변환. <i>예: REST API 컨트롤러, 데이터베이스 매퍼, ViewModel 등.</i></li>
                <li><span class="highlight">Frameworks & Drivers</span>: 외부 기술(데이터베이스, 웹 서버, 프레임워크 등)과 연결되는 가장 바깥쪽 계층. 이 계층은 교체 가능해야 하며, 나머지 계층에 영향을 미치지 않아야 합니다.</li>
            </ul>
        
            <h3>클린 아키텍처의 이점</h3>
            <ul>
                <li><span class="highlight">1) 유지보수 용이:</span> 각 계층이 독립적이기 때문에 특정 계층의 변경이 다른 계층에 영향을 미치지 않습니다.</li>
                <li><span class="highlight">2) 테스트 용이:</span> 각 계층을 독립적으로 단위 테스트할 수 있습니다.</li>
                <li><span class="highlight">3) 확장성:</span> 새로운 기능을 추가하거나, 외부 시스템(예: 데이터베이스, API) 교체가 상대적으로 쉬워집니다.</li>
                <li><span class="highlight">4) 기술 독립성:</span> 특정 프레임워크나 라이브러리에 종속되지 않기 때문에 프로젝트가 성숙할수록 더 높은 자유도를 제공합니다.</li>
            </ul>
        
            <h3>클린 아키텍처 설계 방법 (구체적인 구현 고려)</h3>
            <ul>
                <li><span class="highlight">계층 나누기:</span> 
                    <ul>
                        <li>엔티티: 핵심 도메인 로직을 정의.</li>
                        <li>유즈케이스: 애플리케이션의 기능 로직을 정의.</li>
                        <li>인터페이스 어댑터: 데이터 형식 또는 API와 같은 외부 입력을 애플리케이션 내부에서 사용할 수 있는 형태로 변환.</li>
                        <li>프레임워크: 구현 기술(예: Spring, Django, Flask 등).</li>
                    </ul>
                </li>
                <li><span class="highlight">의존성 역전 원칙(DIP) 적용:</span> 고수준 모듈(비즈니스 로직)은 저수준 모듈(외부 시스템, 데이터베이스)과 독립적으로 설계. 인터페이스를 사용하여 구현부를 추상화.</li>
                <li><span class="highlight">인터페이스 기반 설계:</span> 유즈케이스와 외부 의존성을 분리하기 위해 인터페이스 활용. 외부 시스템이나 기술이 변경되더라도 내부 비즈니스 로직은 영향을 받지 않음.</li>
                <li><span class="highlight">테스트 우선 접근:</span> 각 계층의 독립적인 테스트 용이성을 고려. 핵심 비즈니스 로직(도메인 & 유즈케이스 계층)을 Mock 객체나 Stubs를 사용해 단위 테스트 작성.</li>
            </ul>
        
            <h2>주의해야 할 점</h2>
            <ul>
                <li><span class="highlight">1) 복잡성 증가:</span> 간단한 프로젝트에서는 클린 아키텍처가 오히려 과도하게 느껴질 수 있음. 복잡하고 큰 시스템에서 주로 유효함.</li>
                <li><span class="highlight">2) 추상화 과다:</span> 필요 이상으로 인터페이스와 계층을 만들면 코드가 복잡해질 수 있음. 필수적인 추상화만 수행.</li>
                <li><span class="highlight">3) 초기 설계 비용:</span> 초기 구현이 다소 오래 걸릴 수 있음. 그러나 장기적으로는 유지보수와 확장성에서 투자 대비 효과를 얻을 수 있음.</li>
            </ul>
        
            <h3>클린 아키텍처 도입 가이드라인</h3>
            <ul>
                <li>작은 애플리케이션부터 시작하여 점진적으로 확장.</li>
                <li>테스트 우선 접근법(TDD)을 적극 고려.</li>
                <li>코드 리뷰와 연속적인 리팩토링을 통해 계층 간 의존성을 명확히 유지.</li>
                <li>필요한 경우에만 계층을 도입하여 불필요한 복잡성을 피함.</li>
            </ul>
        
            <p>클린 아키텍처는 장기적인 소프트웨어 개발의 효율성을 극대화하는 데 강력한 방법론입니다. 하지만 프로젝트 특성에 따라 적절히 적용하는 것이 중요합니다. 😊</p> 
 

        <h2>3. 코드 스멜의 해결 방법</h2>
            <p>코드 스멜(Code Smell)이란, 코드가 특정 문제를 일으키거나 더 나아가 유지보수성과 가독성을 떨어뜨릴 가능성이 높은 코드의 특성을 뜻합니다.</p>
            <p>코드 스멜은 프로그램이 작동에 지장을 주지 않더라도, 장기적으로 버그 발생이나 리팩토링 비용 증가를 유발할 가능성이 큰 신호라고 볼 수 있습니다. 코드 스멜은 일반적으로 구현상의 실수라기보다는 비효율적 설계나 안티패턴에서 기인하며, 소프트웨어 개발 과정에서 발생할 수 있는 구조적 품질 문제를 나타냅니다.</p>
        
            <h3>코드 스멜의 특징</h3>
            <ul>
                <li><span class="highlight">1) 감지 가능성:</span> 코드 스멜은 소프트웨어가 제대로 작동하는 경우에도 코드에서 특정 패턴이나 구조적 문제를 살펴보면 쉽게 발견됩니다.</li>
                <li><span class="highlight">2) 직접적인 오류가 아님:</span> 코드 스멜 자체가 프로그램 오류를 나타내는 것은 아니지만, 코드의 품질 저하와 유지보수 문제를 초래하는 기반이 될 수 있습니다.</li>
                <li><span class="highlight">3) 리팩토링 필요성:</span> 코드 스멜을 발견하면 코드 리팩토링(구조 개선)을 통해 문제를 해결하거나 줄이는 것이 중요합니다.</li>
            </ul>
        
            <h3>대표적인 코드 스멜 유형과 해결 방법</h3>
            <h4>긴 함수(Long Method)</h4>
            <p><span class="highlight">문제:</span> 함수(또는 메서드)가 너무 길어서 하나의 함수가 여러 일을 처리하고, 가독성이 떨어지며 테스트 및 유지보수가 어려워짐.</p>
            <p><span class="highlight">해결 방법:</span> 함수 추출(Extract Method): 코드를 논리적으로 나누어 새로운 함수로 분리. 중복 코드를 제거하고 DRY(Don't Repeat Yourself) 원칙 적용.</p>
        
            <h4>긴 클래스(Large Class)</h4>
            <p><span class="highlight">문제:</span> 클래스가 너무 많은 책임을 가지게 되어, "단일 책임 원칙(Single Responsibility Principle, SRP)"을 위반하게 됨.</p>
            <p><span class="highlight">해결 방법:</span> 클래스 분리(Split Class): 클래스의 역할과 책임을 분석하여 서로 다른 책임을 가진 클래스를 분리. 중복 코드 제거: 특정 동작을 별도의 클래스로 추출.</p>
        
            <h4>중복 코드(Duplicated Code)</h4>
            <p><span class="highlight">문제:</span> 유사하거나 동일한 코드가 프로그램 내 여러 곳에 반복적으로 나타남.</p>
            <p><span class="highlight">해결 방법:</span> 함수 추출(Extract Method): 중복된 코드를 하나의 함수로 추출. 상속이나 컴포지션을 활용하여 중복을 줄임. 재사용 가능 클래스로 분리.</p>
        
            <h4>긴 매개변수 목록(Long Parameter List)</h4>
            <p><span class="highlight">문제:</span> 함수의 매개변수 개수가 너무 많아 가독성을 해치고, 각 매개변수의 역할을 이해하기 힘들어짐.</p>
            <p><span class="highlight">해결 방법:</span> 객체로 그룹화: 관련된 매개변수를 객체로 묶어서 전달. 매개변수의 역할을 간소화하고, 불필요한 매개변수를 제거.</p>
        
            <h4>너무 많은 if/else 또는 switch문(Too Many Conditionals)</h4>
            <p><span class="highlight">문제:</span> 조건문이 지나치게 많으면 가독성이 떨어지고, 로직 변경 시 유지보수가 어려워짐.</p>
            <p><span class="highlight">해결 방법:</span>  </p>
                <ul>
                    <li>전략 패턴(Strategy Pattern): 조건문을 객체로 전환하여 처리.</li>
                    <li>다형성 활용: 상속을 통해 동작을 분리.</li>
                </ul>
           
        
            <h4>코드 스멜 개선 방법 (리팩토링)</h4>
            <ul>
                <li><span class="highlight">1) 리팩토링 우선 접근:</span> 코드 스멜을 발견하면 즉시 해결을 시도하지 말고, 전체적인 코드 구조를 고려한 후 리팩토링을 계획적으로 수행.</li>
                <li><span class="highlight">2) 테스트 기반 리팩토링:</span> 코드 리팩토링 이전에 충분한 테스트 코드를 작성하여 기존 기능이 깨지지 않는지 확인.</li>
                <li><span class="highlight">3) 작은 단위로 나누기:</span> 리팩토링을 작은 단계로 나누어 작업하여 변경점의 리스크를 줄임.</li>
                <li><span class="highlight">4) 코드 리뷰 및 협업:</span> 팀원들과 코드 리뷰를 진행하여 코드 스멜을 찾고 개선점을 논의.</li>
            </ul>
        
            <h4>코드 스멜 예방 방법</h4>
            <ul>
                <li><span class="highlight">1) 좋은 코딩 컨벤션 준수:</span> 팀에서 일관된 코딩 스타일을 정하고 이를 준수.</li>
                <li><span class="highlight">2) 단위 테스트 작성:</span> 테스트 가능하게 코드를 작성하여 유지보수성을 향상.</li>
                <li><span class="highlight">3) 모듈화 및 계층화 설계:</span> 코드를 모듈 단위로 설계하여 역할과 책임을 분리.</li>
                <li><span class="highlight">4) 정기적 코드 검토:</span> 코드 리뷰와 정기적 리팩토링을 통해 스멜 제거.</li>
            </ul>

        
        

        <h2>4. 테스트 주도 개발(TDD)</h2>
     
    <h3>1) Red: 실패하는 테스트 작성</h3>
    <p>구현할 기능을 정의하는 <span class="highlight">단위 테스트(Unit Test)</span>를 작성합니다. 이 단계에서는 아직 해당 기능이 구현되지 않았으므로 테스트가 실패해야 합니다. 실패하는 테스트를 확인함으로써, 테스트가 정확하게 동작하고 있는지 확인합니다.</p>
    <p><span class="highlight">목표:</span> 올바르게 실패하는 테스트 작성</p>

    <h3>2) Green: 테스트를 통과하는 최소한의 코드 작성</h3>
    <p>실패한 테스트를 통과하기 위해 최소한의 기능 구현 코드를 작성합니다. 코드가 깔끔하거나 최적화되어 있을 필요는 없으며, 테스트를 통과하는 것이 가장 중요합니다.</p>
    <p><span class="highlight">목표:</span> 테스트를 통과 (Green 상태)</p>

    <h3>3) Refactor: 코드 및 테스트 리팩토링</h3>
    <p>Green 상태에서 작성한 코드는 종종 지저분하거나 임시적인 경우가 많기에 이를 보다 깔끔하게 개선합니다. 기능은 그대로 유지하면서 중복 제거, 가독성 향상, 최적화를 위한 리팩토링을 수행합니다. 리팩토링 이후에도 테스트가 <span class="highlight">성공(Green)</span>으로 통과하는지 확인합니다.</p>
    <p><span class="highlight">목표:</span> 중복을 제거하고, 코드를 개선하여 확장 가능성을 높임.</p>

    <h3>TDD의 특장점</h3>
    <ul>
        <li><span class="highlight">1) 안정성 높은 코드 작성:</span> 테스트를 먼저 작성하기 때문에, 이후 발생할 수 있는 변경의 영향을 쉽게 식별할 수 있습니다. 리팩토링 중 버그가 발생해도 테스트를 통해 즉시 문제를 식별하고 수정할 수 있습니다.</li>
        <li><span class="highlight">2) 작고 명확한 단위로 개발:</span> TDD는 개발을 작고 명확한 단위로 나누어 지속적으로 검증 가능하게 만듭니다. 따라서 복잡한 기능도 단계적으로 구현할 수 있습니다.</li>
        <li><span class="highlight">3) 높은 품질의 리팩토링 지원:</span> 테스트가 코드를 보호해주기 때문에, 기존 코드를 과감히 리팩토링할 수 있습니다. 변경 사항 이후에도 기존 기능이 올바르게 동작함을 보장받습니다.</li>
        <li><span class="highlight">4) 명확한 요구사항 정의:</span> 테스트 코드가 구현 목표를 명확히 정의하므로, 새로운 요구사항을 오해 없이 구현할 수 있습니다.</li>
        <li><span class="highlight">5) 디버깅 시간 절약:</span> 사전에 테스트와 코드를 함께 작성하기 때문에, 디버깅 시간 대신 새로운 기능 개발 및 개선에 집중할 수 있습니다.</li>
    </ul>

    <h3>TDD와 리팩토링의 관계</h3>
    <p>TDD와 리팩토링은 서로를 보완하는 관계입니다.</p>
    <ul>
        <li><span class="highlight">TDD는 리팩토링을 안전하게 수행할 수 있는 기반을 제공합니다.</span> 작성한 테스트는 리팩토링 시 기능을 안전하게 보호하는 역할을 하며, 개발자는 테스트를 신뢰하면서 코드와 구조를 자유롭게 변경하거나 최적화할 수 있습니다.</li>
        <li><span class="highlight">리팩토링은 TDD의 품질을 높이는 도구입니다.</span> Green 단계에서 만들어진 기능 코드는 보통 최적화되지 않거나 유지보수성이 낮을 수 있습니다. 리팩토링을 통해 코드 구조를 개선하고, 확장성을 높이며, 잠재적인 코드 스멜을 제거할 수 있습니다.</li>
    </ul>

    <h3>TDD를 효과적으로 수행하기 위한 팁</h3>
    <ul>
        <li><span class="highlight">1) 작은 단위로 시작하기:</span> 너무 큰 단위의 테스트(예: 통합 테스트)가 아니라, <span class="highlight">단위 테스트(Unit Test)</span>로 시작하세요. 즉, 하나의 함수 또는 메서드가 동작하는지 집중적으로 확인합니다.</li>
        <li><span class="highlight">2) 테스트 간 단절 유지:</span> 테스트는 서로 독립적으로 작성하여, 하나의 테스트 실패가 다른 테스트에 영향을 주지 않도록 합니다.</li>
        <li><span class="highlight">3) "가장 단순한 코드로 통과":</span> Green 단계에서는 간단한 코드를 우선 작성하여 테스트를 통과시키는 데만 집중합니다.</li>
        <li><span class="highlight">4) 테스트 커버리지 유지:</span> 모든 주요 기능과 예외 상황을 커버할 수 있는 테스트를 작성합니다. 그러나 테스트 커버리지 100%가 목표가 아닌, 의미 있는 테스트를 작성하는 것이 중요합니다.</li>
        <li><span class="highlight">5) 지속적인 리팩토링:</span> 코드를 복잡하게 만드는 모든 요소에 대해 주기적으로 리팩토링을 수행합니다. TDD는 리팩토링과 함께 <span class="highlight">지속 개선(Continuous Improvement)</span>의 핵심 도구로 작용합니다.</li>
    </ul>

    <h3>TDD의 한계 및 주의점</h3>
    <ul>
        <li><span class="highlight">1) 초기 진입 장벽이 높을 수 있음:</span> 처음 TDD를 도입하는 개발자는 "테스트를 먼저 작성"하는 방식에 익숙하지 않아 혼란스러울 수 있습니다.</li>
        <li><span class="highlight">2) 과도한 테스트 작성:</span> 모든 코드를 테스트하려고 하면 과도한 노력과 시간이 소요될 수 있습니다. 핵심 로직에 집중하는 것이 중요합니다.</li>
        <li><span class="highlight">3) 기능 구현 속도 저하:</span> 초기 개발 속도가 느려 보일 수 있지만, 장기적으로 유지보수성과 안정성에서 엄청난 이점을 제공합니다.</li>
        <li><span class="highlight">4) 테스트 코드의 유지보수 필요:</span> 테스트 코드 역시 소프트웨어의 일부이므로 지속적으로 수정하고 관리해야 합니다.</li>
    </ul>

    <h3>마무리</h3>
    <p><span class="highlight">테스트 주도 개발(TDD)</span>는 효과적으로 코드 품질을 높이며 리팩토링의 안전한 기반을 제공합니다. 코드와 테스트를 함께 작성하고, 테스트를 바탕으로 리팩토링을 반복하는 과정으로 간단, 명확, 가독성 높은 코드를 얻을 수 있습니다.</p>
    <p>TDD는 단순히 개발 방법론 그 이상으로, 개발자의 코딩 철학과 사고방식을 개선하는 데도 도움을 줄 수 있습니다.</p>
    <p>꾸준히 연습하고 팀에 적용하면, TDD는 장기적인 개발 생산성과 협업의 질을 모두 높여줄 것입니다! 😊</p>

    <h3>단위 테스트(Unit Test)</h3>
 
    <p>단위 테스트(Unit Test)는 소프트웨어 <span class="highlight">가장 작은 단위(함수, 메서드, 클래스 등)</span>를 개별적으로 테스트하여 해당 단위가 제대로 동작하는지 검증하는 소프트웨어 테스트 방식입니다.</p>
    <p>주로 개발자의 관점에서 작성되며, 작성한 로직과 비즈니스 규칙이 예상한 대로 동작하는지를 확인하는 데 중점을 둡니다.</p>
    <p>리팩토링 관점에서 단위 테스트는 안전망(Safety Net) 역할을 해주어 기존 기능이 리팩토링 과정에서도 올바르게 작동하도록 보장합니다.</p>

    <h3>단위 테스트의 특징</h3>
    <ul>
        <li><span class="highlight">1) 작고 독립적인 테스트:</span> 단위 테스트는 특정 기능에 집중하여, 서로 의존성 없이 독립적으로 동작합니다. 테스트가 실패하면 문제가 발생한 개별 단위를 정확히 식별할 수 있습니다.</li>
        <li><span class="highlight">2) 빠른 실행:</span> 단위 테스트는 격리된 작은 코드 조각을 테스트하기 때문에 실행 속도가 빠릅니다. 리팩토링 중에도 빠르게 실행하여 수정 사항의 영향을 즉시 확인할 수 있습니다.</li>
        <li><span class="highlight">3) 코드 품질 개선:</span> 단위 테스트를 작성하면 더 읽기 쉽고 테스트 가능한 코드 구조를 설계하도록 동기를 부여합니다. 또한, 테스트를 통해 코드 스멜(Code Smell)을 조기에 발견할 수 있습니다.</li>
        <li><span class="highlight">4) 변경 사항에 대한 안정성 보장:</span> 리팩토링 후에도 테스트가 통과한다면, 버그 없이 코드 변경이 이루어졌음을 확인할 수 있습니다.</li>
    </ul>

    <h3>왜 리팩토링에 단위 테스트가 중요한가?</h3>
    <ul>
        <li><span class="highlight">1) 버그를 신속히 발견:</span> 리팩토링 동안 코드 구조가 변화하며, 무심코 기존 동작을 변경할 수 있습니다. 단위 테스트는 변화를 감지하고 빠르게 피드백을 제공합니다.</li>
        <li><span class="highlight">2) 기능 안정성 보장:</span> 리팩토링 과정에서도 기존의 비즈니스 로직이나 기능이 깨지지 않도록 보장합니다. 즉, 테스트가 통과한다는 것은 "기존 동작이 유지된다"는 것을 의미합니다.</li>
        <li><span class="highlight">3) 리팩토링 안전망(Safety Net):</span> 단위 테스트를 작성해두면 리팩토링이나 신규 기능 개발 시 기존의 기능이 올바르게 동작하는지 확인하는 보호막 역할을 합니다.</li>
        <li><span class="highlight">4) 모듈화된 코드 작성 지원:</span> 테스트 가능성이 높은 코드는 보통 단일 책임 원칙(SRP)에 따라 모듈화되어 있으며, 이는 자연스럽게 리팩토링하기 쉬운 코드로 이어집니다.</li>
    </ul>

    <h3>리팩토링 시 단위 테스트 활용 방법</h3>
    <ul>
        <li><span class="highlight">1) 리팩토링 전 테스트 작성:</span> 리팩토링 전에 기존 기능에 대한 단위 테스트를 작성하여 "리팩토링 전후 기능이 동일함"을 보장합니다. 테스트가 작성되지 않은 코드라면 리팩토링 전 반드시 테스트를 작성하세요.</li>
        <li><span class="highlight">2) 테스트 우선 작성:</span> 리팩토링 중 변경될 코드에 대해 예상 결과를 검증하는 테스트 케이스를 먼저 작성한 후 리팩토링을 수행합니다.</li>
        <li><span class="highlight">3) 테스트 실행 후 리팩토링:</span> 코드 변경이나 구조 수정 후에는 테스트를 실행하여 리팩토링이 기존 동작에 영향을 주지 않았는지 확인합니다.</li>
        <li><span class="highlight">4) 테스트 커버리지 확인:</span> 리팩토링 후 테스트가 변경된 코드 영역을 충분히 커버하는지 확인합니다. 단순히 "커버리지 100%"가 아니라 의미 있는 테스트를 작성하는 것이 중요합니다.</li>
    </ul>

    <h3>결론</h3>
    <p>단위 테스트와 리팩토링은 서로를 강화하는 선순환 관계를 가지며, 꾸준한 테스트 작성과 리팩토링은 소프트웨어 품질과 유지보수성을 극대화합니다.</p>

        <h2>5. SOLID 원칙</h2>
    
    <h3>SOLID 원칙(SOLID Principles)</h3>
    <p>SOLID 원칙은 객체 지향 설계에서 높은 품질의 코드 구조를 만들기 위한 다섯 가지 설계 원칙을 제시한 규칙입니다. 이 원칙들은 유지보수성, 확장성, 재사용성을 높이는 데 초점을 맞추며, 리팩토링 과정에서도 자주 사용됩니다.</p>
    <p>리팩토링은 이 원칙들을 실천에 옮기면서 더 효율적이고 읽기 쉬운 코드를 만드는 데 핵심적인 역할을 합니다. 아래는 SOLID 원칙과 리팩토링 관점에서의 설명입니다.</p>

    <h4>1) 단일 책임 원칙 (SRP, Single Responsibility Principle)</h4>
    <p><span class="highlight">원칙:</span> 객체는 단 하나의 책임(변화 이유)만 가져야 합니다. "하나의 클래스는 하나의 기능만을 수행해야 한다"는 원칙입니다.</p>
    <p><span class="highlight">리팩토링 관점:</span> 리팩토링 과정에서 하나의 클래스나 메서드가 너무 많은 일을 하고 있는 경우, 이를 분리하여 단일 책임을 유지하도록 합니다. SRP를 따르지 않는 코드는 수정이 어려워지고, 특정 기능의 변경이 예상치 못한 다른 기능에 영향을 줄 가능성이 높습니다.</p>
    <p><span class="highlight">적용 사례:</span> Extract Class 패턴: 한 클래스가 여러 책임을 지는 경우, 관련 있는 기능을 새로운 클래스로 추출합니다.</p>

    <h4>2) 개방-폐쇄 원칙 (OCP, Open Closed Principle)</h4>
    <p><span class="highlight">원칙:</span> "소프트웨어 엔티티(클래스, 모듈, 함수)는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다." 즉, 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있어야 합니다.</p>
    <p><span class="highlight">리팩토링 관점:</span> 리팩토링 과정에서 하드코딩된 로직이나 반복되는 조건문을 <span class="highlight">다형성(polymorphism)</span>으로 대체합니다. 코드 수정 없이 새로운 요구 사항을 만족시키기 위해 상속이나 인터페이스 구현을 활용합니다.</p>

    <h4>3) 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)</h4>
    <p><span class="highlight">원칙:</span> "자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다." 즉, 부모 클래스에서 정의된 작업이 자식 클래스에서도 정상적으로 동작해야 합니다.</p>
    <p><span class="highlight">리팩토링 관점:</span> 리팩토링 과정에서 잘못된 상속 구조를 확인하고, 이를 적절히 조정합니다. 상속이 적합하지 않은 경우 <span class="highlight">컴포지션(composition)</span>을 활용해 올바른 설계를 만듭니다.</p>
    <p><span class="highlight">위반 예시와 해결:</span> 자식 클래스가 부모 클래스의 인터페이스를 따르지 않거나, 예상치 못한 동작을 하는 경우.</p>

    <h4>4) 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)</h4>
    <p><span class="highlight">원칙:</span> "사용되지 않는 인터페이스를 구현하지 않도록 한다." 하나의 큰 인터페이스를 여러 개의 작은 인터페이스로 나누는 것이 더 바람직합니다.</p>
    <p><span class="highlight">리팩토링 관점:</span> 리팩토링 과정에서 과도하게 많은 메서드를 가진 인터페이스가 있다면, 이를 여러 인터페이스로 나눕니다. 불필요한 의존성을 줄이고, 특정 객체가 필요한 기능만 구현하도록 개선합니다.</p>

    <h4>5) 의존 역전 원칙 (DIP, Dependency Inversion Principle)</h4>
    <p><span class="highlight">원칙:</span> "고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화된 것에 의존해야 한다." 즉, 구체적인 구현 대신 추상화(interface 또는 abstract class)에 의존해야 합니다.</p>
    <p><span class="highlight">리팩토링 관점:</span> 리팩토링 과정에서는 구체적인 클래스와의 결합을 피하고, 이를 추상화를 통해 인터페이스나 추상 클래스로 변경하여 의존성을 줄입니다. DIP를 활용하면 새로운 구현체를 쉽게 교체할 수 있어 확장성이 높아집니다.</p>
 

  <h2>6. KISS(Keep It Simple, Stupid)</h2>
    <p><span class="highlight">KISS 원칙</span>은 "단순하게 유지하라"는 기본 철학을 따르는 개발 접근 방식입니다. 코드는 불필요한 복잡성 없이 간결하고 직관적으로 작성되어야 하며, 복잡한 설계는 피해야 합니다.</p>
    <p>중복된 코드 제거나 불필요한 복잡성을 줄이기 위해 리팩토링을 수행합니다. KISS 원칙은 코드를 단순화함으로써 읽기 쉽고 이해하기 쉬운 설계를 추구하며, 리팩토링의 중요한 목표 중 하나를 지원합니다.</p>
    <p>너무 많은 책임이 하나의 메서드나 클래스에 집중되어 있다면, 이를 간단하고 독립적인 단위들로 나누는 작업이 필요합니다.</p>

    <h2>7. 모듈화(Modularization)</h2>
    <p><span class="highlight">개념:</span> 모듈화는 애플리케이션을 더 작은 <span class="highlight">독립적인 단위(모듈)</span>로 나누는 원칙입니다. 각각의 모듈은 특정 기능을 담당하도록 설계됩니다.</p>
    <p>모듈화는 단일 책임 원칙(SRP)을 적용한 것을 구체화한 개념이라 볼 수 있습니다.</p>
    <p><span class="highlight">리팩토링 관점:</span> 리팩토링 작업의 첫 단계는 보통 큰 클래스나 메서드를 모듈화하는 것입니다. 모듈화를 통해 코드 재사용성을 높이고, 특정 모듈의 수정이 다른 모듈에 영향을 끼치지 않도록 합니다. 하나의 메서드나 클래스가 여러 가지 일을 처리하고 있다면 이를 분리(<span class="highlight">Extract Class</span> 또는 <span class="highlight">Extract Method</span>)하는 작업이 포함됩니다.</p>

    <h2>8. 컨벤션(Code Convention 또는 Coding Standard)</h2>
    <p><span class="highlight">개념:</span> 코드 컨벤션은 코드 작성 스타일과 원칙을 정의하여 팀 내 코드의 일관성을 유지하도록 돕는 개발 규칙입니다. 일반적으로 네이밍 규칙, 들여쓰기 스타일, 주석 작성 방법 등을 포함합니다.</p>
    <p><span class="highlight">리팩토링 관점:</span> 리팩토링 작업에서는 기존 코드를 읽기 쉽고 일관성 있게 만드는 것이 중요한데, 컨벤션을 따르지 않는 코드는 가독성을 심각하게 저해할 수 있습니다. 컨벤션을 준수하지 않는 코드를 리팩토링하는 것은 깔끔한 코드 작성의 기본적인 접근 방법입니다.</p>

    <h2>9. 리팩토링 카탈로그(Refactoring Catalog)</h2>
    <p><span class="highlight">개념:</span> 리팩토링 카탈로그는 코드 개선을 위해 사용할 수 있는 리팩토링 기법의 모음입니다. 대표적으로 Martin Fowler의 <span class="highlight">"Refactoring: Improving the Design of Existing Code"</span>에서 소개된 기법들이 있습니다.</p>
    <p><span class="highlight">리팩토링 관점:</span> 리팩토링 카탈로그는 문제 상황에 따라 적합한 리팩토링 기법을 신속하게 선택하여 적용하는 데 도움을 줍니다. 코드 스멜(Code Smell, 문제를 나타내는 신호)이 발생했다면 이를 제거하기 위해 적합한 방안을 참고할 수 있습니다.</p>

    <h2>10. CI/CD(Continuous Integration/Continuous Deployment)</h2>
    <p><span class="highlight">개념:</span> CI(Continuous Integration)은 코드 변경이 자주 이뤄지는 팀 환경에서 지속적으로 코드를 통합하고 테스트하는 프로세스를 말합니다. CD(Continuous Deployment)는 통합된 코드를 자동으로 배포하는 프로세스를 포함합니다.</p>
    <p><span class="highlight">리팩토링 관점:</span> 리팩토링은 기존 코드를 개선하는 과정에서 작동 방식에 영향을 줄 수 있기 때문에, 지속적인 테스트 및 통합이 필수입니다. CI/CD는 리팩토링 중 오류를 조기에 발견하고, 리팩토링된 코드가 프로덕션 수준에서도 신뢰할 수 있음을 보장합니다.</p>
    <p><span class="highlight">리팩토링과의 상호작용:</span></p>
    <ul>
        <li><span class="highlight">1) 자동화된 테스트 필요:</span> 리팩토링 후 기존 기능이 깨졌는지 CI 시스템에서 자동으로 테스트를 실행해 문제를 미리 발견.</li>
        <li><span class="highlight">2) 코드 리뷰 및 배포 간소화:</span> 작은 단위로 리팩토링을 완료한 후 CI/CD를 통해 안정적으로 프로덕션에 배포.</li>
        <li><span class="highlight">3) 릴리즈 부담 감소:</span> CD를 통해 코드가 안전하고 자동화된 절차를 거쳐 배포되므로, 리팩토링 작업의 결과를 빠르게 확인 가능.</li>
    </ul>

    <h3>리팩토링 주요 포인트</h3>
    <ul>
        <li><span class="highlight">Extract Method:</span> 중복된 로직 및 복잡한 흐름을 메서드로 분리하여 가독성을 향상.</li>
        <li><span class="highlight">Renaming:</span> 메서드 및 변수명을 명확히 하여 의도를 명확하게 표현.</li>
        <li><span class="highlight">Introduce Variable:</span> 복잡한 표현식의 값을 변수로 추출.</li>
        <li><span class="highlight">Change Signature:</span> 의미를 명확히 하기 위해 메서드 시그니처 개선.</li>
        <li><span class="highlight">Inline Variable:</span> 불필요한 변수 제거.</li>
    </ul>

    <h2>대표적인 리팩토링 기법</h2>
    <ul>
        <li><span class="highlight">Extract Method (메서드 추출):</span> 긴 메서드를 여러 작은 메서드로 나눔.</li>
        <li><span class="highlight">Inline Method (메서드 내용 직접 삽입):</span> 너무 작은 메서드를 호출 대신 직접 작성.</li>
        <li><span class="highlight">Extract Class (클래스 추출):</span> 하나의 클래스가 너무 많은 책임을 가지는 경우 클래스 분리.</li>
        <li><span class="highlight">Replace Conditional with Polymorphism (조건문을 다형성으로 교체):</span> if/else 또는 switch 대신 상속 및 오버라이드로 처리.</li>
    </ul>

    <h3>결론</h3>
    <p>리팩토링은 단순히 "코드를 바꾸는 것"이 아니라, <span class="highlight">코드 품질을 높이고 협업과 확장을 용이하게</span> 하는 것이 목표입니다. 작업 전에 목표를 명확히 하고, 단위 테스트로 안전성을 확보한 상태에서 적절한 패턴을 선택해 작업하면 효과적인 리팩토링이 가능합니다.</p>
    <p>가독성과 확장성(중복 제거)이 리팩토링의 기본이며, 코드의 구조를 파악하기 쉽게 만들고 협업과 유지보수를 용이하게 합니다.</p>


        <h2>과거 작성했던 코드 중 고치고 싶은 부분이 있다면? </h2>
        <pre>
<code class="language-java">
@PostMapping("/search")
public ModelAndView searchFoodApi(@ModelAttribute FoodInputDto food)   {
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName("food-search");
    SearchResponse searchResponse;
    if(ObjectUtils.isEmpty(food.getFood())) {
        searchResponse = new SearchResponse();
    }else{
        naverSearchServiceImpl.saveFoodKeyword(food.getFood());
        modelAndView.addObject("foodListWithCnt", naverSearchServiceImpl.foodListWithCount());
        searchResponse = naverSearchServiceImpl.foodSearch(food.getFood(), food.getSort() ,1);
    }

    if (searchResponse == null) {
        log.error("네이버 검색 API 호출 실패");
        PageHandler pageHandler = new PageHandler(Integer.parseInt(food.getPage()), 10);
        kakaoSearchServiceImpl.saveFoodKeyword(food.getFood());
        modelAndView.addObject("foodList", kakaoSearchServiceImpl.foodSearch(food.getFood(), "random", Integer.parseInt(food.getPage())).getDocumentList());
        modelAndView.addObject("pageHandler", pageHandler);
        modelAndView.addObject("keyword", food.getFood());
        modelAndView.addObject("foodListWithCnt", kakaoSearchServiceImpl.foodListWithCount());
        log.info("카카오 검색 API 호출 성공");
        return modelAndView;
    }
    log.info("검색 API 및 keyword cnt 호출 성공");
    modelAndView.addObject("foodList", searchResponse.getItems());

    return modelAndView;
}
         </code>   
        </pre>
<p> 1) 일단 캡슐화를 적용하여 리팩토링한다. 그래서 private하게 정리하면 keep it simple. stupid 에 따른 원칙이 적용된다.</p>
<p> 2) 앞으로 발생될 중복된 코드를 private 하게 뺄 수 있고, public한 부분에서 간결하게 코드 파악할 수 있어서 좋다.</p>
        <pre>
<code class="language-java">
            @PostMapping("/search")
public ModelAndView searchFoodApi(@ModelAttribute FoodInputDto food) {
    ModelAndView modelAndView = createBaseModelAndView();
    validateInput(food);

    // 네이버 API 호출
    SearchResponse searchResponse = fetchNaverApiResults(food);
    if (searchResponse ==) {
        // 네이버 호출 실패 시 카카오 API 대체
        return handleKakaoFallback(modelAndView, food);
    }

    // API 호출 성공 시 결과 전달
    populateNaverResults(modelAndView, searchResponse, food);
    return modelAndView;
}

private ModelAndView createBaseModelAndView() {
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName("food-search");
    return modelAndView;
}

private void validateInput(FoodInputDto food) {
    if (ObjectUtils.isEmpty(food.getFood())) {
        throw new IllegalArgumentException("검색어가 비어있습니다.");
    }
}

private SearchResponse fetchNaverApiResults(FoodInputDto food) {
    naverSearchServiceImpl.saveFoodKeyword(food.getFood());
    return naverSearchServiceImpl.foodSearch(food.getFood(), food.getSort(), 1);
}

private ModelAndView handleKakaoFallback(ModelAndView modelAndView, FoodInputDto food) {
    log.error("네이버 검색 API 호출 실패");
    kakaoSearchServiceImpl.saveFoodKeyword(food.getFood());
    PageHandler pageHandler = new PageHandler(Integer.parseInt(food.getPage()), 10);
    
    modelAndView.addObject("foodList", kakaoSearchServiceImpl.foodSearch(
            food.getFood(), "random", Integer.parseInt(food.getPage())).getDocumentList());
    modelAndView.addObject("pageHandler", pageHandler);
    modelAndView.addObject("keyword", food.getFood());
    modelAndView.addObject("foodListWithCnt", kakaoSearchServiceImpl.foodListWithCount());

    log.info("카카오 검색 API 호출 성공");
    return modelAndView;
}

private void populateNaverResults(ModelAndView modelAndView, SearchResponse searchResponse, FoodInputDto food) {
    modelAndView.addObject("foodList", searchResponse.getItems());
    modelAndView.addObject("foodListWithCnt", naverSearchServiceImpl.foodListWithCount());
    log.info("검색 API 및 keyword cnt 호출 성공");
}
</code>
        </pre>
        
    </div>
</body>
    <script>
    // Highlight.js 초기화 스크립트
    document.addEventListener('DOMContentLoaded', (event) => {
        hljs.highlightAll();
    });
</script>
</html>
